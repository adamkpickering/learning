{
  "name": "kubernetes",
  "version": 0,
  "active": true,
  "cards": [
    {
      "id": "lqt4ghquaj",
      "version": 0,
      "active": true,
      "question": "What is a service?",
      "answer": "A way of grouping pods such that they can be routed to as one. There are multiple types.",
      "reviews": [
        {
          "version": 0,
          "result": "easy",
          "datetime": "2024-01-29T17:34:42.569186205Z"
        },
        {
          "version": 0,
          "result": "easy",
          "datetime": "2024-01-26T17:10:20.147969043Z"
        }
      ]
    },
    {
      "id": "2tx2iud6ts",
      "version": 0,
      "active": true,
      "question": "What is the history of the use of docker by kubernetes?",
      "answer": "1) K8s originally used only dockerd as the container engine.\n2) It was recognized that it would be beneficial for it to be possible to\n   use other container engines to make containers a reality in k8s. rkt was\n   the first one.\n3) CRI was defined to solve the problem of docker and rkt having different,\n   and poorly-defined, interfaces to kubelet. For docker, CRI was satisfied\n   by the creation of dockershim, an adaptor for CRI to dockerd inside the k8s\n   project.\n4) dockershim became a burden on the k8s maintainers. Mirantis and Docker agree\n   to maintain a separate adaptor, cri-dockerd, that does the same thing but is\n   in a different tree.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-30T18:51:33.516203545Z"
        },
        {
          "version": 0,
          "result": "hard",
          "datetime": "2024-01-29T17:31:53.923236311Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T18:55:43.137122084Z"
        }
      ]
    },
    {
      "id": "kvdcaiptf4",
      "version": 0,
      "active": true,
      "question": "What does CRI stand for?\nWhere did it originate?\nWhat is it?",
      "answer": "Container Runtime Interface\n\nIt originated in kubernetes.\n\nIt is a gRPC interface that enables us to use many different container engines\nwith the same API. Libraries are available to ease its use.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-30T18:56:37.022602121Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:30:22.399157937Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T18:52:37.430847858Z"
        }
      ]
    },
    {
      "id": "8uassbl30s",
      "version": 0,
      "active": true,
      "question": "There are three daemons that run on each k8s node. What do they do?",
      "answer": "kubelet: starts, stops and runs containers; maintains state of pods; reports to the master\nkube-proxy: a node-level proxy/load balancer\ncontainer runtime: self explanatory",
      "reviews": [
        {
          "version": 0,
          "result": "easy",
          "datetime": "2024-01-29T17:45:05.244601729Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-26T19:03:53.350060503Z"
        }
      ]
    },
    {
      "id": "v1cf1umdvf",
      "version": 0,
      "active": true,
      "question": "What are the 4 parts to the control plane? What do they do?",
      "answer": "etcd: a key-value store that represents the state of the cluster\nAPI server: acts as a broker between REST API requests and the state of etcd\nscheduler: monitors resource usage of nodes (among many other things) and selects which node will run an unscheduled pod\ncontroller manager: a process that manages a set of core k8s controllers, such as replication controller, DaemonSet controller, job controller",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T18:00:14.362406832Z"
        },
        {
          "version": 0,
          "result": "hard",
          "datetime": "2024-01-26T18:34:06.289097867Z"
        }
      ]
    },
    {
      "id": "8ls87e2lgm",
      "version": 0,
      "active": false,
      "question": "What are the five types of controllers? How do they work?",
      "answer": "ReplicaSet: ensures that a specific number of pod replicas are running at any given time\nDeployment: a declarative way of updating pods and ReplicaSets\nStatefulSet: like a Deployment controller, but tracks each pod with a special identity\nDaemonSet: ensures that all, or a subset of, nodes run a copy of a pod\nJob: creates one or more pods and ensures that a specified number of them successfully terminate",
      "reviews": []
    },
    {
      "id": "l396f4wjof",
      "version": 0,
      "active": true,
      "question": "What are the 4 types of services?",
      "answer": "ClusterIP: default, service is only available internally through a cluster-internal IP\n\nNodePort: a static port (called NodePort) is opened on each node, so that traffic can\nreach the service via \u003cnode_ip\u003e:\u003cnode_port\u003e; a ClusterIP service, which NodePort\nservice routes to, is automatically created\n\nLoadBalancer: traffic comes into cluster via an external load balancer (for the cloud)\n\nExternalName: literally a CNAME record pointing to an external service; can cause\nproblems with protocols that use the domain name (HTTP, HTTPS)",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T18:04:08.619876854Z"
        },
        {
          "version": 0,
          "result": "hard",
          "datetime": "2024-01-26T18:15:28.097430507Z"
        }
      ]
    },
    {
      "id": "spn5pqfr6n",
      "version": 0,
      "active": true,
      "question": "What are the three kube-proxy modes, and how do they work?",
      "answer": "userspace: kube-proxy configures service IP to redirect (in iptables) to a\nrandom port that it opens; it then manually passes traffic to and from pods\nthat are in that service\n\niptables: kube-proxy configures iptables with per-service and per-endpoint\nrules that pass traffic without it ever touching it\n\nIPVS: similar to IPTables, but uses IP virtual server kernel feature to improve\nperformance over iptables",
      "reviews": [
        {
          "version": 0,
          "result": "easy",
          "datetime": "2024-01-29T17:45:49.052860624Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T18:51:14.14297683Z"
        }
      ]
    },
    {
      "id": "m2h9nqzu6z",
      "version": 0,
      "active": true,
      "question": "What are the Endpoints and EndpointSlice resources, and how do they differ?",
      "answer": "Every Service has a corresponding Endpoints resource, which is created by\nthe Endpoints controller as it polls pods and finds the set that match the\nService's selector criteria. It then creates the Endpoints resource by assembling\nthe pod IPs and ports that are open for each pod.\n\nHowever this does not scale. EndpointSlices are a way of addressing this.\nEndpointSlices list all of the pod IPs for each unique combination of port and\nservice, up to a maximum of 100 (by default) IPs per EndpointSlice. For very\nlarge services, this is easier to manage.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-30T18:59:30.085072464Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:42:44.946541766Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T19:01:21.391688486Z"
        }
      ]
    },
    {
      "id": "fdq9w2cbp6",
      "version": 0,
      "active": true,
      "question": "How do I access a pod from a service \"foo\" inside a namespace \"bar\" from a pod in another namespace?",
      "answer": "Use name foo.bar",
      "reviews": [
        {
          "version": 0,
          "result": "easy",
          "datetime": "2024-01-29T17:52:09.963196235Z"
        },
        {
          "version": 0,
          "result": "easy",
          "datetime": "2024-01-26T17:09:46.203856376Z"
        }
      ]
    },
    {
      "id": "7o97anqksh",
      "version": 0,
      "active": true,
      "question": "How are Labels and Annotations similar, and how are they different?",
      "answer": "Similar:\n- both key/value pairs\n- same rules for key (prefix/name)\n\nDifferent:\n- Labels are for selecting certain objects\n- Labels' values are limited in length and character set\n- Annotations are for metadata\n- Annotations' values can contain anything, including structured data",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:44:15.191504893Z"
        },
        {
          "version": 0,
          "result": "hard",
          "datetime": "2024-01-26T17:09:07.673078855Z"
        }
      ]
    },
    {
      "id": "kifvfd33xw",
      "version": 0,
      "active": false,
      "question": "What object would I use to limit compute consumption in a namespace?",
      "answer": "ResourceQuota",
      "reviews": []
    },
    {
      "id": "dyvat3p152",
      "version": 0,
      "active": true,
      "question": "What are the following:\nVolume\nPersistentVolume\nPersistentVolumeClaim\nStorageClass",
      "answer": "Volume: a place to store files; that is tied to the lifetime of a pod\n\nPersistentVolume: a Volume that has a lifetime independent of a pod; manually\nprovisioned by an administrator, or dynamically provisioned using StorageClasses\n\nPersistentVolumeClaim: an object that is created by a user when they want to\nrequest a PersistentVolume\n\nStorageClass: used by administrators to describe the \"classes\" of storage they offer;\ndifferent classes might map to QoS levels, backup policies etc",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-30T18:45:35.155268997Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:43:38.159337312Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T18:47:10.279897644Z"
        }
      ]
    },
    {
      "id": "re4uxv0wl1",
      "version": 0,
      "active": true,
      "question": "For the externalIPs field to work, what is required?",
      "answer": "clusterIP cannot be None, since the externalIPs are NAT'd to the clusterIP.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:44:27.372315228Z"
        },
        {
          "version": 0,
          "result": "easy",
          "datetime": "2024-01-26T18:29:57.16564108Z"
        }
      ]
    },
    {
      "id": "axsgbloax5",
      "version": 0,
      "active": false,
      "question": "Name the five fields of the ServicePort object, and if applicable, their options",
      "answer": "name: the name of the port; optional if only one port is defined on service protocol: the protocol used (TCP, UDP, HTTP, PROXY, SCTP)  nodePort: the port that is opened on each node for a NodePort service port: the port that the service exposes externally (with externalIPs) or internally to the cluster, to other services/pods targetPort: the port on the pod that the service connects to (defaults to `port` if not defined)",
      "reviews": []
    },
    {
      "id": "flcxa9gotx",
      "version": 0,
      "active": false,
      "question": "What is the purpose of the Open Service Broker API standard?",
      "answer": "It is a way for platforms (think k8s master) to talk to cloud providers in order to find out what services (think AWS EC2 instance) they offer, and to get them.",
      "reviews": []
    },
    {
      "id": "tdw21mwdsh",
      "version": 0,
      "active": false,
      "question": "What Service field is used to specify how traffic coming from an external source is routed through iptables to a pod? What are its possible values, and what do they mean?",
      "answer": "externalTrafficPolicy   Local: preserves client source IP and routes traffic to a pod on the node that received the traffic; might result in uneven load spreading in the cluster   Cluster: obscures the client source IP and may route traffic to a pod on another node; better load spreading",
      "reviews": []
    },
    {
      "id": "w0z3khvb4j",
      "version": 0,
      "active": false,
      "question": "What is sessionAffinity option for a Service?  What are the options and what do they mean?",
      "answer": "It concerns how IP traffic is passed to pods, which is relevant for connection-based protocols.   None (default): no session affinity ClientIP: ensures that connections from a particular client are passed to the same pod within a specified time period",
      "reviews": []
    },
    {
      "id": "o16uh8xgil",
      "version": 0,
      "active": false,
      "question": "What is a headless service? Why might you use one? What are the two kinds?",
      "answer": "A service with clusterIP: None. Used to interface with service discovery mechanisms other than Kubernetes'. Also used for exposing statefulsets.   With selector statement: an Endpoints resource is created, but nothing is configured by kube-proxy. The service DNS name is configured to do round-robin load balancing across pods.   Without selector statement: you can create your own Endpoints resource (which must have the same name as the service). Or, a CNAME record will be created for an ExternalName service.",
      "reviews": []
    },
    {
      "id": "z5njdycu1k",
      "version": 0,
      "active": true,
      "question": "What are the four ways of authenticating API requests?",
      "answer": "client certificates\nbearer tokens\nauthenticating proxy\nHTTP basic auth",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-30T18:46:03.702522037Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-29T17:40:25.395263196Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T16:59:44.012118082Z"
        }
      ]
    },
    {
      "id": "du7kr5ealn",
      "version": 0,
      "active": true,
      "question": "What are the five possible states a Pod object can be in?",
      "answer": "Pending: pod has been created as a resource, but is either not yet scheduled or containers are being created\nRunning: pod has been bound to a node, and all containers have been created, and are running\nSucceeded: all containers in the pod have terminated in success, and will not be restarted\nFailed: all containers in pod have terminated, and at least one terminated in failure\nUnknown: the state of the pod could not be obtained, typically due to an error in communicating with the host of the pod",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-30T18:56:04.532961986Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:46:07.826195964Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T18:30:37.228298215Z"
        }
      ]
    },
    {
      "id": "67zcz16au1",
      "version": 0,
      "active": true,
      "question": "What are the 4 ways API requests are authorized?\nExplain them.",
      "answer": "webhook: an external HTTP(S) service is consulted\nABAC: enforces policies defined in a static file\nRBAC: authorization info is stored in API objects\nNode: specifically for programs that run on nodes (i.e. kubelet), which limits access to resources that pertain to that node",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-30T18:54:34.698548656Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-29T17:59:44.275173642Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T17:32:25.289682814Z"
        }
      ]
    },
    {
      "id": "5u0o94o4re",
      "version": 0,
      "active": true,
      "question": "How does logging work at the node level?",
      "answer": "Logs from components that run inside a container (anything in a pod) are\nwritten using the container runtime's configured logging driver to /var/log.\n\nLogs from components that do not run inside a container are logged to journald,\nas they are systemd services.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-30T18:55:03.392094774Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T18:02:00.889502205Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T18:49:53.298595986Z"
        }
      ]
    },
    {
      "id": "21nm7j8wo7",
      "version": 0,
      "active": true,
      "question": "What is a Role/ClusterRole?\nHow do they differ?",
      "answer": "Role defines rules that whitelist parts of the k8s API for a specific namespace.\nClusterRole is the same thing but for all namespaces.",
      "reviews": [
        {
          "version": 0,
          "result": "easy",
          "datetime": "2024-01-29T17:51:55.894305157Z"
        },
        {
          "version": 0,
          "result": "hard",
          "datetime": "2024-01-26T17:26:28.141546184Z"
        }
      ]
    },
    {
      "id": "16mjgwi6ln",
      "version": 0,
      "active": true,
      "question": "What is a RoleBinding/ClusterRoleBinding?\nHow do they differ?",
      "answer": "RoleBindings give the permissions described by a Role or ClusterRole to one or more\nusers in a namespace. ClusterRoleBindings are the same, but in all namespaces.\n\nIt is possible to reference a ClusterRole in a RoleBinding; in this case the user\ngets the permissions defined in the ClusterRole, but only in the namespace listed\nin the RoleBinding.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-30T18:44:03.380903465Z"
        },
        {
          "version": 0,
          "result": "hard",
          "datetime": "2024-01-29T17:52:56.167316635Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T17:42:48.783901103Z"
        }
      ]
    },
    {
      "id": "9k5av1u20b",
      "version": 0,
      "active": true,
      "question": "How does Traefik get access to the token that is created in its ServiceAccount?",
      "answer": "When the pod is created the token from the serviceaccount is mounted\nat /var/run/secrets/kubernetes.io/serviceaccount. Traefik then knows\nto pick the token up from here and use it in requests to the API server.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:36:30.294325939Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-26T17:04:12.999646764Z"
        }
      ]
    },
    {
      "id": "taufgwf4j6",
      "version": 0,
      "active": true,
      "question": "What are the 3 keys to every rule in a Role/ClusterRole? What is surprising about this?",
      "answer": "apiGroups: list of v1, extensions/v1beta1 etc\nresources: list of resources in those api groups\nverbs: list of verbs that are permitted on those resources\n\nIt is surprising that we have only apiGroups, and no information about what\nversions of the resources in those groups each rule applies to. But really,\nthis isn't needed - versions are only used to differentiate different schema\nfor resources.",
      "reviews": [
        {
          "version": 0,
          "result": "hard",
          "datetime": "2024-01-29T17:28:44.647617851Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T17:28:21.226772685Z"
        }
      ]
    },
    {
      "id": "t5zhe8nczk",
      "version": 0,
      "active": false,
      "question": "List the 13 verbs that can be used in role/clusterrole rules.",
      "answer": "- get - list - watch - create - update - patch - delete - deletecollection - use - bind  - escalate - impersonate - userextras",
      "reviews": []
    },
    {
      "id": "esmjbn0uv6",
      "version": 0,
      "active": false,
      "question": "Define the following terms: node affinity/antiaffinity inter-pod affinity/antiaffinity taint toleration",
      "answer": "node affinity/antiaffinity: a property of pods that causes them to run (either for sure or just preference) on a subset of nodes   inter-pod affinity/antiaffinity: a property of pods that causes them to be attracted to or repelled by pods already running on a node   taint: a property of a node that allows it to repel a set of pods   toleration: a property of a pod that lets it tolerate a taint on a node (it can run on that node)",
      "reviews": []
    },
    {
      "id": "7edtszry5u",
      "version": 0,
      "active": true,
      "question": "Which component (of several possible ones) creates the Pod object,\nwhat is its state at that time, and how does it make it onto a node?",
      "answer": "ReplicaSet controller creates Pod object in API server. Pod's state\nis Pending at this point. Scheduler notices Pod is not assigned to\na node, so it does so. kubelet picks up this definition and carries\nout actions to create Pod on its node.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T18:00:55.677866578Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-26T17:31:39.685858966Z"
        }
      ]
    },
    {
      "id": "5k7zyfskog",
      "version": 0,
      "active": true,
      "question": "What is a CNI plugin?\nWhat is it called by?\nHow are input and output done?",
      "answer": "An executable that takes inputs through env vars and may give\noutput via a JSON object on stdout. Inserts a network interface\ninto the network namespace of a container, and then configures it,\nand any networking outside of the container, so that things work.\n\nCalled as a subprocess of container engine when it wants to do\nsomething with a container's networking (ADD, DEL, CHECK, VERSION).",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-30T18:47:28.109070255Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-29T17:48:11.04018364Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T17:23:37.587873902Z"
        }
      ]
    },
    {
      "id": "ibigfut0yk",
      "version": 0,
      "active": true,
      "question": "What is kube-proxy responsible for, compared to the CNI plugin?",
      "answer": "kube-proxy: exclusively responsible for services, and load-balancing traffic\ndestined for that belong to a service\n\nCNI plugin: responsible for pod and inter-pod networking",
      "reviews": [
        {
          "version": 0,
          "result": "hard",
          "datetime": "2024-01-30T18:42:53.375092176Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-29T17:35:44.250784627Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T19:03:11.034378091Z"
        }
      ]
    },
    {
      "id": "i98nm8co0m",
      "version": 0,
      "active": false,
      "question": "What are the two ways you can expose each unique pod in a StatefulSet? What are the names you use to get to the pod in each case?",
      "answer": "1) Use a headless service, which usually would give you a single DNS name that round-robin load balances to different pods. In the case of a StatefulSet we get multiple DNS records, of the form ${statefulset_name}-${ordinal}.${service_name}.${namespace}.cluster.local   2) Use one service to refer to each pod; each service selects for the label \"statefulset.kubernetes.io/pod-name",
      "reviews": []
    },
    {
      "id": "g8eypgk3se",
      "version": 0,
      "active": true,
      "question": "What is the format of the name of a Pod that is in a StatefulSet?",
      "answer": "${statefulset_name}-${ordinal}",
      "reviews": [
        {
          "version": 0,
          "result": "easy",
          "datetime": "2024-01-29T18:03:34.832870017Z"
        },
        {
          "version": 0,
          "result": "easy",
          "datetime": "2024-01-26T17:05:21.247326131Z"
        }
      ]
    },
    {
      "id": "3k5yubblh0",
      "version": 0,
      "active": true,
      "question": "In the case of updating the container version in the Pods, how does a Deployment update the Pods?",
      "answer": "It creates a whole new ReplicaSet and gradually decreases the number\nof replicas in the old ReplicaSet as it gradually increases the number\nof replicas in the new ReplicaSet.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-30T18:47:59.021396619Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:51:00.269623078Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T17:24:27.117233987Z"
        }
      ]
    },
    {
      "id": "b2dryh9lib",
      "version": 0,
      "active": true,
      "question": "What are the three top-level keys that every k8s resource has?",
      "answer": "apiVersion\nkind\nmetadata",
      "reviews": [
        {
          "version": 0,
          "result": "easy",
          "datetime": "2024-01-30T18:49:53.932603077Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:39:41.012592419Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T17:03:10.914479814Z"
        }
      ]
    },
    {
      "id": "2q3dshejlp",
      "version": 0,
      "active": true,
      "question": "What are the two typical types of API groups?\nWhat is their apiVersion key?\nWhat is their REST path?",
      "answer": "core (legacy)\napiVersion: \u003cversion\u003e\n/api/\u003cversion\u003e\n\nnamed groups/CRD groups\napiVersion: \u003cgroup_name\u003e/\u003cversion\u003e\n/apis/\u003cgroup_name\u003e/\u003cversion\u003e",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:54:07.629338061Z"
        },
        {
          "version": 0,
          "result": "hard",
          "datetime": "2024-01-26T17:44:19.979931455Z"
        }
      ]
    },
    {
      "id": "mlk8gjbr30",
      "version": 0,
      "active": true,
      "question": "What are API groups, and what is their purpose?",
      "answer": "Versioned groups of resources that are usually related.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:37:45.702536186Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-26T18:44:24.178404471Z"
        }
      ]
    },
    {
      "id": "3k9jan4imy",
      "version": 0,
      "active": true,
      "question": "What are the three stages an API version goes through on its way to acceptance?\nWhat do they mean for their component resources?\nWhat do they look like in an apiVersion?",
      "answer": "alpha\n- bugs are likely\n- API may change\n- v1alpha1\n\nbeta\n- considered safe regarding bugs\n- API may change\n- v1beta1\n\nstable\n- considered safe regarding bugs\n- API is stable\n- v1",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-30T18:54:05.566973554Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:45:19.421666018Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T18:57:07.71720602Z"
        }
      ]
    },
    {
      "id": "kqmfx2y5uk",
      "version": 0,
      "active": true,
      "question": "What are API versions versions of?",
      "answer": "They are versions of the resources in their API group. Each\nAPI group + API version combo has a list of resources with a\nspecific structure.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:41:26.054518289Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-26T17:39:43.890938141Z"
        }
      ]
    },
    {
      "id": "mkynvkpqpp",
      "version": 0,
      "active": true,
      "question": "What does v1alpha2 mean?",
      "answer": "It is the second alpha version of the eventual v1 version of the group.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:28:54.971608992Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-26T18:47:24.114221979Z"
        }
      ]
    },
    {
      "id": "pwtqmyj02a",
      "version": 0,
      "active": true,
      "question": "What are the two ways of getting traffic into the cluster without using a LoadBalancer service?",
      "answer": "1) Use a NodePort service. This configures each node of the cluster to\n   listen on a specific port. When traffic hits that port coming from\n   outside of the cluster, it is NAT'd to one of the containers in the\n   Endpoints field of the NodePort service.\n\n2) Use any service type with an ExternalIP field. This will cause traffic\n   hitting any node (independent of what their actual IP addr is) with the\n   destination address specified in the ExternalIP field to be routed to\n   one of the containers in the Endpoints field of the service.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T18:02:59.506195069Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-26T17:34:07.545270167Z"
        }
      ]
    },
    {
      "id": "b6yf3rx8md",
      "version": 0,
      "active": true,
      "question": "What service types does the externalIP field apply to?",
      "answer": "Any that have a clusterIP.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-30T18:46:21.828531529Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:39:19.49420836Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T17:09:31.540694745Z"
        }
      ]
    },
    {
      "id": "5pgg7qkpe7",
      "version": 0,
      "active": true,
      "question": "What rules are there for case of keys and values in k8s resource files?",
      "answer": "keys are camelCase\nvalues are PascalCase",
      "reviews": [
        {
          "version": 0,
          "result": "easy",
          "datetime": "2024-01-29T17:46:31.605584824Z"
        },
        {
          "version": 0,
          "result": "easy",
          "datetime": "2024-01-26T17:00:15.238625766Z"
        }
      ]
    },
    {
      "id": "uyd0iesiir",
      "version": 0,
      "active": false,
      "question": "What are the two service fields I always get mixed up? What does each specify?",
      "answer": "externalTrafficPolicy: specifies how traffic coming in gets routed to a pod   sessionAffinity: specifies policies that let you send traffic coming in to the same pod based on source IP",
      "reviews": []
    },
    {
      "id": "wx9qw00ecq",
      "version": 0,
      "active": false,
      "question": "Configure a Pod with the following attributes: - name \"example\" - namespace \"default\" - serves the contents of the \"index.html\" file, read-only, from the \"myconfig\" configMap volume on TCP port 80 with port name \"http\" - uses the default python http server (can be started with command `python -m http.server --bind 0.0.0.0 --directory \u003cdir\u003e 80`) - has the environment variable MYVAR=helloworld configured on it - never restarts if it crashes - give it the \"testSA\" service account credentials",
      "answer": "apiVersion: v1 kind: Pod  metadata:   name: example   namespace: default spec:   serviceAccountName: testSA    restartPolicy: Never   containers:   - name: server     image: python:3.10     command: [\"python\", \"-m\", \"http.server\"]     args: [\"--bind\", \"0.0.0.0\", \"--directory\", \"/srv\", \"80\"]     env:     - name: MYVAR       value: helloworld     ports:     - containerPort: 80       name: http       protocol: TCP     volumeMounts:     - name: myvolume       mountPath: /srv       readOnly: true   volumes:   - name: myvolume     configMap:       name: myconfig       items:       - key: index.html         path: index.html",
      "reviews": []
    },
    {
      "id": "auhiqe6grw",
      "version": 0,
      "active": false,
      "question": "Define a cluster IP Service that exposes TCP port 80 to port 5500 with the label \"app: myapp\".",
      "answer": "apiVersion: v1 kind: Service metadata:   name: example   namespace: default spec:   type: ClusterIP   selector:     app: myapp   ports:     - targetPort: 80       port: 5500       protocol: TCP",
      "reviews": []
    },
    {
      "id": "6xz9z9dvbc",
      "version": 0,
      "active": false,
      "question": "Define a ConfigMap with one file, index.html, with content \"hello world",
      "answer": "apiVersion: v1 kind: ConfigMap metadata:   name: example   namespace: default data:   index.html: \"hello world",
      "reviews": []
    },
    {
      "id": "21btai70q1",
      "version": 0,
      "active": false,
      "question": "In minikube, how are services exposed?",
      "answer": "NodePort services are exposed by a separate IP address that represents the minikube Node. So you access them via \u003cnode_ip\u003e:\u003cport\u003e. You can get this info via `minikube service \u003cservice_name\u003e --url`.   LoadBalancer services get NodePorts by default, so you can access them the same way. However, you can also start a local load balancer. To do this, run `minikube tunnel` in a separate terminal. Then, another IP address will be created that represents the load balancer, and you will be able to access the service via that IP and the service port(s).",
      "reviews": []
    },
    {
      "id": "li3r8dambh",
      "version": 0,
      "active": false,
      "question": "What is Knative?",
      "answer": "Serverless, but on k8s instead of a cloud platform.",
      "reviews": []
    },
    {
      "id": "xuwbcqk5rl",
      "version": 0,
      "active": true,
      "question": "What two methods are used to get a service mesh access to communication?\nWhat advantages does a service mesh provide?\nWhat are some examples of these advantages?",
      "answer": "1) Most commonly, applications that integrate with a service mesh use a sidecar\n   container that proxies all communication\n2) Netflix uses application libraries to proxy communication, which is presumably\n   more performant\n\nsecurity: can automatically encrypt all traffic that goes between APIs\nobservability: can see which services are talking to which services, how frequently, what content is etc\nreliability: can prevent accidental DoSing if an API is overloaded by rate limiting requests; can send communication to less-utilized places",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:42:09.643911929Z"
        },
        {
          "version": 0,
          "result": "hard",
          "datetime": "2024-01-26T17:30:11.357517044Z"
        }
      ]
    },
    {
      "id": "l8y0r23a3w",
      "version": 0,
      "active": true,
      "question": "What is fleet?",
      "answer": "Fleet is a set of controllers and resources that make gitops easy\nand scalable to a million clusters. It watches repositories that\nhave kubernetes manifests, helm charts or kustomize configs, and when\nchanges are noticed, makes those changes a reality. Turns everything\ninto helm charts before deployment.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:29:33.677854466Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-26T17:06:05.234005337Z"
        }
      ]
    },
    {
      "id": "mjje3xhw1s",
      "version": 0,
      "active": false,
      "question": "What is linkerd?",
      "answer": "A service mesh. Has an emphasis on performance and minimalism.",
      "reviews": []
    },
    {
      "id": "hbyh9nskhh",
      "version": 0,
      "active": true,
      "question": "Describe the structure of a Helm chart, and what each file is for.",
      "answer": "Chart.yaml: chart metadata\nvalues.yaml: defaults for chart variables\ntemplates/\n  NOTES.txt: a tmpl that is printed out to user upon chart install\n  _helpers.tpl: define blocks of tmpl text that are used frequently\n  pod.yaml: a k8s manifest that is also a go template\n  service.yaml: a k8s manifest that is also a go template",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-30T18:55:41.571580665Z"
        },
        {
          "version": 0,
          "result": "hard",
          "datetime": "2024-01-29T18:01:45.483751511Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T17:36:29.211899326Z"
        }
      ]
    },
    {
      "id": "yl0qm55fgc",
      "version": 0,
      "active": false,
      "question": "What is the basic layout of a kustomize config?",
      "answer": "myapp/   kustomization.yaml   deployment.yaml   service.yaml",
      "reviews": []
    },
    {
      "id": "h3c5j8u8i4",
      "version": 0,
      "active": false,
      "question": "What are the four classes of things you find in a kustomization.yaml file?",
      "answer": "Resources, generators, transformers and validators.",
      "reviews": []
    },
    {
      "id": "8dl3h4e1v3",
      "version": 0,
      "active": true,
      "question": "What is the idea behind Kustomize?",
      "answer": "You can define base resources, and then overlay various transformations\nonto them to make, for example, versions of those resources for different\nstages with the corresponding different config.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T18:02:25.128322817Z"
        },
        {
          "version": 0,
          "result": "easy",
          "datetime": "2024-01-26T17:05:05.783340683Z"
        }
      ]
    },
    {
      "id": "l52dpwcufi",
      "version": 0,
      "active": false,
      "question": "How is kubewarden deployed to a cluster? How does it work?",
      "answer": "In kubernetes, you can make any incoming objects be validated/mutated by an external webhook service by defining ValidatingWebhookConfiguration or MutatingWebhookConfiguration resources. These resources specify: 1) the URL of a webhook to talk to 2) which resources to check against the webhook   Kubewarden is deployed as kubewarden-controller to the cluster. Then, the user creates PolicyServer and ClusterAdmissionPolicy resources (which are kubewarden CRDs). Each PolicyServer resource becomes a deployment; this is the server that k8s interfaces with via webhook. Each PolicyServer may have multiple ClusterAdmissionPolicy's attached to it.   When the set of CAPs assigned to a PS changes, kubewarden-controller changes the PS config (which is stored in a ConfigMap) to match, and initiates a rollout of the PS deployment. In this way, all pods for that PS are restarted with the new config.   When kubewarden-controller first notices a PS, several things are done: 1) a TLS cert is created for the PS and stored in a Secret 2) a Deployment is created for the PS 3) a ClusterIP Service is created that points to the PS 4) a ValidatingWebhookConfiguration or MutatingWebhookConfiguration resource is created to make resources in the cluster have to go through the PS",
      "reviews": []
    },
    {
      "id": "ao8zoelkzn",
      "version": 0,
      "active": false,
      "question": "What is the idea behind epinio?",
      "answer": "The idea is to make it easy to go from code in a repository to a running application on a k8s cluster in one step.   In order to make this possible, there are things that must be taken care of:   1) detecting the project type and building it into an OCI image   2) defining k8s resources to turn that OCI image into a running service   3) having things installed on the cluster that make things more secure, reliable and observable: linkerd, metrics, kubewarden etc",
      "reviews": []
    },
    {
      "id": "2vcdt9xfup",
      "version": 0,
      "active": false,
      "question": "What is skaffold?",
      "answer": "Skaffold is like epinio, but lesser in scope. Also uses buildpacks behind the scenes. Monitors your app for changes and restarts/deploys it locally. One can plug in tools to use for all of these things. Can deploy to production too apparently.",
      "reviews": []
    },
    {
      "id": "e80oftjvhd",
      "version": 0,
      "active": false,
      "question": "What is kim? How does it work?",
      "answer": "Stands for Kubernetes Image Manager. It consists of:   1) a CLI tool that is used to interface with the whole thing 2) a BuildKit daemon bound to the Kubelet's underlying containerd socket 3) a server-side agent that the CLI uses to manage images (push, pull etc)   Basically, it enables building images locally on your k3s cluster.",
      "reviews": []
    },
    {
      "id": "pgsh7tayvy",
      "version": 0,
      "active": true,
      "question": "Order the following from highest-level to lowest-level:\n\nclient-go\nwrangler\nlasso",
      "answer": "wrangler\nlasso\nclient-go",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:30:37.608909293Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-26T17:34:59.70624584Z"
        }
      ]
    },
    {
      "id": "rykmcn848r",
      "version": 0,
      "active": true,
      "question": "What are the three ibraries that are core to k8s?",
      "answer": "k8s.io/apimachinery\nk8s.io/client-go\nk8s.io/api",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:44:41.056640896Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-26T17:37:06.086604172Z"
        }
      ]
    },
    {
      "id": "uaf2r4sr1m",
      "version": 0,
      "active": true,
      "question": "What are some reasons we might use a controller framework?",
      "answer": "- The bare cache.SharedIndexInformer doesn't help us at all when handler\n  functions return errors. Using a controller framework lets us handle\n  handler errors more intelligently with retries etc.\n\n- They can efficiently manage creation of k8s clients and cache.SharedIndexInformers.\n\n- They can generate code in order to make it easier to define custom\n  types and controllers.\n\n- They can define code that handles common controller patterns.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-30T18:49:11.803792868Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:33:58.73779601Z"
        },
        {
          "version": 0,
          "result": "failed",
          "datetime": "2024-01-26T18:43:27.477343002Z"
        }
      ]
    },
    {
      "id": "ovq6egfknt",
      "version": 0,
      "active": true,
      "question": "How does one create a controller without the use of any controller frameworks?\nHow does this work?",
      "answer": "You would construct a cache.SharedInformer, passing it a cache.ListerWatcher\nand the resource you want it to watch for. You would then register handlers\nwith it to be called when there are resource updates.",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:59:11.213244048Z"
        },
        {
          "version": 0,
          "result": "hard",
          "datetime": "2024-01-26T18:28:19.271801726Z"
        }
      ]
    },
    {
      "id": "7bwhlwv672",
      "version": 0,
      "active": true,
      "question": "How does helm store release metadata?",
      "answer": "There are three kinds of storage backends:\n\nsecret: uses Secrets to store release metadata; this is the default\n\nconfigmap: uses ConfigMaps to store information on releases\n\nsql: uses an SQL database to store release metadata; this is useful when\n  there is a lot of release metadata (but it seems dumb to me)",
      "reviews": [
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-30T18:50:15.441030607Z"
        },
        {
          "version": 0,
          "result": "normal",
          "datetime": "2024-01-29T17:37:14.101079177Z"
        }
      ]
    }
  ]
}
